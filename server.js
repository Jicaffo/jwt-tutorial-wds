import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

const app = express();
dotenv.config() // Loads our dotenv variables into the process.env runtime variables of node
const PORT = 3000;
// To generate random character sequences for the .env variables we can run Node directly in the terminal writting "node", and then using crypto module to create one randomly: require('crypto').randomBytes(64).toString('hex')

// Dummy DB to simulate authentication (starts empty)
const usersDB = []
const posts = [
    {
        username: "Juan",
        title: "Post 1"
    },
    {
        username: "Kyle",
        title: "Post 2"
    },
    {
        username: "Juan",
        title: "Post 3"
    },
]
const encrypt = async (plainTextPassword) => {

    const hashedPasword = await bcrypt.hash(plainTextPassword, 10) // saltRounds = 10

    console.log(`${plainTextPassword} (plainTextPassword) + (autogenerated salt) = ${hashedPasword} (hashedPasword)`)

    return hashedPasword;
}
const authenticateUser = async (req, res, next) => {
    // If we dont recieve data through req.body, err.
    if (!req.body?.username || !req.body?.password) {
        res.status(400).json(`Missing info.`)
        return false
    }

    const loginUser = {
        username: req.body.username,
        password: req.body.password
    }

    const foundUser = usersDB.find( dbUser => dbUser.username === loginUser.username)
    //console.log("User found: ", foundUser)

    if (!foundUser) {
        res.status(404).json(`User not found.`)
        return false
    }
    else {
        // bcrypt.compare() makes comparision secure (preventing timming attack through "constant timing algorithms") and returns a boolean
        const passwordMatches = await bcrypt.compare(loginUser.password, foundUser.password)
        .catch( (err) => {
            console.log(err)
            res.status(500).json(`Error comparing passwords`)
            return false
        })
        
        if (!passwordMatches){
            res.status(403).json(`Password doesn't match`)
            return false
        } else {
            req.infoToStore = {
                username: foundUser.username,
                password: foundUser.password,
                creationTimestamp: Date.now()
            }
            return true;
        }
    }
    
}
const authenticateToken = (req, res, next) => {
    // Get token if present in request
    const authHeader = req.headers['authorization']
    const token = authHeader && authHeader.split(" ")[1]
    if (!token) return res.status(401).send("Sin accessToken")

    // If it is, verify its integrity
    jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, jwtStoredInfo) => {
        if (err) res.status(403).send("Forbidden")

        req.userData = jwtStoredInfo
        next()
    })

}

app.use(express.json())

// Get all user posts
app.get("/posts", authenticateToken, (req, res)=>{
    res.json({
        status: "success",
        message: `All current user post obtained correctly`,
        data: {
            loggedUserPosts: posts.filter(post => post.username === req.userData.username)
        }
    })
})

// Create a new user
app.post("/users", async (req, res)=>{
    console.log(req.body);
    if (!req.body?.username || !req.body?.password) return res.status(400).json(`Missing info.`)

    const hashedPassword = await encrypt(req.body.password)
        .catch( (err) => {
            console.log(err)
            return res.sendStatus(500) // In case encryption fails
        })

    const newUser = {
        username: req.body.username,
        password: hashedPassword
    }
    usersDB.push(newUser) // Add user to the "DB"

    const userNames = usersDB.map(user => user.username)
    res.status(201).json({ // 201 = Created
        status: "success",
        message: `New user '${newUser.username}' added to DB correctly.`,
        data:{
            allUsers: userNames
        }
    })
})


app.post("/login", async (req, res)=>{
    // User authentication
    const userIsValidated = await authenticateUser(req, res)

    if (!userIsValidated) return

    console.log("User authenticated! Info to save: ", req.infoToStore);

    // To create the JWT, we pass to the sign() function the info to store in it, and the server secret for encoding it. Future requests will have it included as an authorization header.
    const accessToken = jwt.sign(req.infoToStore, process.env.ACCESS_TOKEN_SECRET)

    res.status(200).json({
        status: "success",
        message: `Access Token created succesfully`,
        data: {
            accessToken
        }
    })

})

app.listen(PORT, ()=>{
    console.log(`*** Server running on port ${PORT}***`)
})