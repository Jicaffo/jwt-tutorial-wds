import 'dotenv/config'; // Loads our dotenv variables into the process.env runtime variables of node
// see https://github.com/motdotla/dotenv#how-do-i-use-dotenv-with-import
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

const app = express();
const PORT = process.env.PORT;
// To generate random character sequences for the .env variables we can run Node directly in the terminal writting "node", and then using crypto module to create one randomly: require('crypto').randomBytes(64).toString('hex')

// Dummy DB to simulate authentication (starts empty)
// It should really be an external DB to which both servers have access to
const usersDB = []
const posts = [
    {
        username: "Juan",
        title: "Post 1"
    },
    {
        username: "Kyle",
        title: "Post 2"
    },
    {
        username: "Juan",
        title: "Post 3"
    },
]
const encrypt = async (plainTextPassword) => {

    const hashedPasword = await bcrypt.hash(plainTextPassword, 10) // saltRounds = 10
        .catch( (err) => {
            console.log(err)
            return res.sendStatus(500) // In case encryption fails
        })

    console.log(`${plainTextPassword} (plainTextPassword) + (autogenerated salt) = ${hashedPasword} (hashedPasword)`)

    return hashedPasword;
}
const authenticateAccessToken = (req, res, next) => {
    // Get token through header if present in request
    const authHeader = req.headers['authorization']
    const recievedAccessToken = authHeader && authHeader.split(" ")[1]

    if (!recievedAccessToken) return res.status(401).send("No Access Token on headers")

    // If it is, verify its integrity and save userData in req
    jwt.verify(recievedAccessToken, process.env.ACCESS_TOKEN_SECRET, (err, jwtStoredInfo) => {
        if (err) return res.status(403).send("Forbidden")

        req.userData = jwtStoredInfo
        next()
    })

}

app.use(express.json())

// Gets all logged in user's posts.
//Should send a valid Access Token through headers (obtained through /login or /refresh-token)
app.get("/posts", authenticateAccessToken, (req, res)=>{
    // Should manually provide an "Authorization" req header with "Bearer " + accessToken (obtained previously from  /login in authServer)
    // req.userData gets populated in authenticateToken()
    const results = req.userData?.username ?
        posts.filter(post => post.username === req.userData.username)
        : null

    res.json({
        status: "success",
        message: `All current user post obtained correctly`,
        data: {
            loggedUserPosts: results
        }
    })
})

// Creates a new user
app.post("/users", async (req, res)=>{
    console.log(req.body);
    if (!req.body?.username || !req.body?.password) return res.status(400).json(`Missing info.`)

    const hashedPassword = await encrypt(req.body.password)

    const newUser = {
        username: req.body.username,
        password: hashedPassword
    }
    usersDB.push(newUser) // Add user to the "DB"

    const userNamesOnly = usersDB.map(user => user.username)
    res.status(201).json({ // 201 = Created
        status: "success",
        message: `New user '${newUser.username}' added to DB correctly.`,
        data:{
            allUsers: userNamesOnly
        }
    })
})

app.listen(PORT, ()=>{
    console.log(`*** Server running on port ${PORT}***`)
})