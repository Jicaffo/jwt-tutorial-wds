import 'dotenv/config'; // Loads our dotenv variables into the process.env runtime variables of node
// see https://github.com/motdotla/dotenv#how-do-i-use-dotenv-with-import
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const app = express();
// To generate random character sequences for the .env variables we can run Node directly in the terminal writting "node", and then using crypto module to create one randomly: require('crypto').randomBytes(64).toString('hex')
const PORT = process.env.PORT2;

// Dummy DB to simulate authentication (starts empty, hardcoded populated on /login for testing purposes)
// It should really be an external DB to which both servers have access to
const usersDB = []

// Dummy DB (Should really be a DB or Redis Cache)
let refreshTokensDB = []

const createUser = async (name, password) => {
    const hashedPassword = await encrypt(password)

    const newUser = {
        username: name,
        password: hashedPassword,
        userPropertyStoredOnDB: "Dummy Property"
    }
    usersDB.push(newUser) // Add user to the "DB"
}
const encrypt = async (plainTextPassword) => {

    const hashedPasword = await bcrypt.hash(plainTextPassword, 10) // saltRounds = 10
        .catch( (err) => {
            console.log(err)
            return res.sendStatus(500) // In case encryption fails
        })

    //console.log(`${plainTextPassword} (plainTextPassword) + (autogenerated salt) = ${hashedPasword} (hashedPasword)`)

    return hashedPasword;
}
const authenticateUser = async (req, res) => {
    // If we dont recieve data through req.body, err.
    if (!req.body?.username || !req.body?.password)
        return res.status(400).json(`Missing info.`)

    const loginUser = {
        username: req.body.username,
        password: req.body.password
    }

    const foundUser = usersDB.find( dbUser => dbUser.username === loginUser.username)
    //console.log("User loging in: ", loginUser.username, " / User found: ", foundUser)

    if (!foundUser) return res.status(404).json(`User not found.`)

    // bcrypt.compare() makes comparision secure (preventing timming attack through "constant timing algorithms") and returns a boolean
    const passwordMatches = await bcrypt.compare(loginUser.password, foundUser.password)
        .catch( (err) => {
            console.log(err)
            res.status(500).json(`Error in passwords comparing process`)
            return false
        })
    
    if (!passwordMatches) return res.status(403).json(`Password doesn't match`)
            
    // User authenticated correctly: Construct the object with the info to store in memory, and persist on JWT eventually
    req.userData = {
        username: foundUser.username,
        password: foundUser.password,
        userPropertyStoredOnDB: foundUser.userPropertyStoredOnDB,
        lastLogin: Date.now()
    }
}

app.use(express.json())

// On successful login, generates and responds with both new authToken and refreshToken, with userData inside.
// Different refreshTokens should allow simultaneous sessions on diferent devices for example. // TODO: If already logged in on same client, don't create new refreshToken
app.post("/login", async (req, res)=>{
    
    await createUser("Juan", "1234"); // User hardcoded dummy example for quick endpoint testing

    await authenticateUser(req, res) // Populates req.userData and handles errors and responses
    if (!req.userData) return
    //console.log("User authenticated!, req.userData: ", req.userData);

    // Creation of access and refresh tokens:
    // accessToken is used to give access to the app itself, but expires quickly (usually around 10/15/30m)
    const accessToken = jwt.sign(userData, process.env.ACCESS_TOKEN_SECRET, {expiresIn: '60s'})
  
    // refreshToken is used to generate new accessTokens once they expire. Could be or not automatically expired (forces to re-login periodically), but can manually be revoked through /logout route, making auth process safer (as long as we can revoke the refreshToken, access will be limited at max to accessToken expiring time). // TOCHECK: does it needs to have userData? it's ok it does?
    const refreshToken = jwt.sign(req.userData, process.env.REFRESH_TOKEN_SECRET, {expiresIn: '30d'})
    refreshTokensDB.push(refreshToken) // Saves refresh token on a DB.

    res.status(200).json({
        status: "success",
        message: `User authenticated. Access Token created succesfully.`,
        data: {
            // TOCHECK: Client should store locally both this tokens (localStorage reccommended?).
            accessToken,
            refreshToken
        }
    })

})

// If providing correct refreshToken through body, generates a new accessToken.
app.post("/refresh-token", (req, res) => {   
    const refreshToken = req.body.refreshToken
    if (!refreshToken) return res.status(401).json(`Missing refresh token.`)
    if (!refreshTokensDB.includes(refreshToken)) return res.status(403).json(`Don't have access: Refresh Token Unmatched`)

    // TOCHECK: De donde saca la info de user (queda guardada en el login en el access y refreshToken)
    jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, rtUserData) => {
        if (err) return res.status(403).json(`Don't have access: Tampered Refresh Token`)
        // user object here will have additional info (iat, etc), so in this case we select just the info we want to really save on the access token
        console.log(rtUserData)
        const accessToken = generateExpiringAccessJWT({
            username: rtUserData.username,
            password: rtUserData.password,
            userPropertyStoredOnDB: rtUserData.userPropertyStoredOnDB,
            lastLogin: rtUserData.lastLogin
        })
        res.status(200).json({
            status: "success",
            message: `Access Token refreshed succesfully`,
            data: {
                accessToken
            }
        })
    })
})

// Revokes the Refresh Token removing it from the DB // TOCHECK: Working, but should be automatically revoked?
app.delete("/logout", (req, res) => {
    refreshTokensDB = refreshTokensDB.filter(token => token !== req.body.refreshToken)
    console.log("refreshTokensDB: ", refreshTokensDB);

    res.status(204).json({
        status: "success",
        message: `Refresh Token deleted succesfully`,
        data: null
    })

})

app.listen(PORT, ()=>{
    console.log(`*** Server running on port ${PORT}***`)
})